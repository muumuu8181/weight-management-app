# ğŸ”’ å®‰å…¨ãªãƒ„ãƒ¼ãƒ«çµ±åˆæ–¹é‡æ›¸

**ä½œæˆæ—¥**: 2025å¹´1æœˆ20æ—¥  
**ä½œæˆè€…**: AI Assistant  
**ç›®çš„**: æ—¢å­˜æ©Ÿèƒ½ã‚’å£Šã•ãšã«å®‰å…¨ã«ãƒ„ãƒ¼ãƒ«ã‚’çµ±åˆã—ã€ãã®éç¨‹ã‚’å®¢è¦³çš„ã«è¨¼æ˜ã™ã‚‹æ–¹æ³•ã‚’ç¢ºç«‹ã™ã‚‹

## ğŸ“‹ ç›®æ¬¡

1. [èƒŒæ™¯ã¨ç¾çŠ¶](#èƒŒæ™¯ã¨ç¾çŠ¶)
2. [çµ±åˆã®åŸºæœ¬æ–¹é‡](#çµ±åˆã®åŸºæœ¬æ–¹é‡)
3. [æ®µéšçš„çµ±åˆãƒ—ãƒ­ã‚»ã‚¹](#æ®µéšçš„çµ±åˆãƒ—ãƒ­ã‚»ã‚¹)
4. [å®¢è¦³çš„è¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ ](#å®¢è¦³çš„è¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ )
5. [å…·ä½“çš„ãªçµ±åˆä¾‹](#å…·ä½“çš„ãªçµ±åˆä¾‹)
6. [ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ—ãƒ©ãƒ³](#ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ—ãƒ©ãƒ³)
7. [å®Ÿè£…ã‚³ãƒ¼ãƒ‰ä¾‹](#å®Ÿè£…ã‚³ãƒ¼ãƒ‰ä¾‹)
8. [ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ](#ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ)

---

## èƒŒæ™¯ã¨ç¾çŠ¶

### ç¾åœ¨ã®ãƒ„ãƒ¼ãƒ«é…ç½®çŠ¶æ³
- **ç·ãƒ„ãƒ¼ãƒ«æ•°**: ç´„40å€‹ä»¥ä¸Š
- **ä¸»è¦é…ç½®å ´æ‰€**:
  - `development/tools/testing/` - 19å€‹
  - `development/tools/universal-auditor/` - 1å€‹
  - `development/tools/code-analysis/` - 6å€‹
  - `package.json`ã‚¹ã‚¯ãƒªãƒ—ãƒˆ - 15å€‹ä»¥ä¸Š

### ç™ºè¦‹ã•ã‚ŒãŸé‡è¤‡ã‚°ãƒ«ãƒ¼ãƒ—
1. **ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãƒã‚§ãƒƒã‚«ãƒ¼** - 4å€‹ï¼ˆåŒä¸€æ©Ÿèƒ½ã®ç•°ãªã‚‹å®Ÿè£…ï¼‰
2. **é‡è¤‡ãƒã‚§ãƒƒã‚«ãƒ¼** - 2å€‹ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ãŒç•°ãªã‚‹ï¼‰
3. **ãƒ‡ãƒ¼ã‚¿æœŸé–“ãƒ†ã‚¹ã‚¿ãƒ¼** - 2å€‹ï¼ˆæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ãŒç•°ãªã‚‹ï¼‰

---

## çµ±åˆã®åŸºæœ¬æ–¹é‡

### ğŸ¯ åŸå‰‡
1. **æ©Ÿèƒ½ä¿å…¨æœ€å„ªå…ˆ** - æ—¢å­˜ã®æ©Ÿèƒ½ã¯100%ç¶­æŒ
2. **æ®µéšçš„ç§»è¡Œ** - æ€¥æ¿€ãªå¤‰æ›´ã‚’é¿ã‘ã€å¾ã€…ã«ç§»è¡Œ
3. **ä¸¦è¡Œé‹ç”¨æœŸé–“** - æ–°æ—§ãƒ„ãƒ¼ãƒ«ã‚’åŒæ™‚ã«å‹•ã‹ã—ã¦æ¯”è¼ƒ
4. **å®Œå…¨ãªè¨¼è·¡** - ã™ã¹ã¦ã®éç¨‹ã‚’è¨˜éŒ²ãƒ»è¨¼æ˜
5. **å³åº§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯** - å•é¡Œç™ºç”Ÿæ™‚ã¯å³åº§ã«å…ƒã«æˆ»ã›ã‚‹

### âš ï¸ ç¦æ­¢äº‹é …
- æ—§ãƒ„ãƒ¼ãƒ«ã®å³åº§ã®å‰Šé™¤
- ãƒ†ã‚¹ãƒˆãªã—ã®æœ¬ç•ªæŠ•å…¥
- è¨¼è·¡ãªã—ã®å¤‰æ›´
- ä¸€åº¦ã«è¤‡æ•°ãƒ„ãƒ¼ãƒ«ã®çµ±åˆ

---

## æ®µéšçš„çµ±åˆãƒ—ãƒ­ã‚»ã‚¹

### Phase 1: æº–å‚™æœŸé–“ï¼ˆ1é€±é–“ï¼‰
```
1. çµ±åˆå¯¾è±¡ãƒ„ãƒ¼ãƒ«ã®å®Œå…¨ãªå‹•ä½œä»•æ§˜æ›¸ä½œæˆ
2. å…¨ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®æ–‡æ›¸åŒ–
3. æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ã®è¨˜éŒ²
4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆï¼ˆgit tag: pre-integration-{tool-name}ï¼‰
```

### Phase 2: é–‹ç™ºæœŸé–“ï¼ˆ2é€±é–“ï¼‰
```
1. æ–°çµ±åˆãƒ„ãƒ¼ãƒ«ã®é–‹ç™ºï¼ˆæ—§ãƒ„ãƒ¼ãƒ«ã¯æ®‹ã™ï¼‰
2. æ—§ãƒ„ãƒ¼ãƒ«ã¨åŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
3. å˜ä½“ãƒ†ã‚¹ãƒˆã®ä½œæˆ
4. ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
```

### Phase 3: ä¸¦è¡Œé‹ç”¨æœŸé–“ï¼ˆ1-2é€±é–“ï¼‰
```
1. ä¸¡ãƒ„ãƒ¼ãƒ«ã‚’åŒæ™‚å®Ÿè¡Œ
2. å‡ºåŠ›ã®è‡ªå‹•æ¯”è¼ƒ
3. å·®åˆ†ã®è¨˜éŒ²ã¨åˆ†æ
4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
```

### Phase 4: æ®µéšçš„åˆ‡ã‚Šæ›¿ãˆï¼ˆ2é€±é–“ï¼‰
```
1. 10%ã®ãƒ†ã‚¹ãƒˆã§æ–°ãƒ„ãƒ¼ãƒ«ä½¿ç”¨
2. 50%ã®ãƒ†ã‚¹ãƒˆã§æ–°ãƒ„ãƒ¼ãƒ«ä½¿ç”¨
3. 100%ã®ãƒ†ã‚¹ãƒˆã§æ–°ãƒ„ãƒ¼ãƒ«ä½¿ç”¨
4. ç›£è¦–æœŸé–“ï¼ˆ1é€±é–“ï¼‰
```

### Phase 5: å®Œäº†ï¼ˆ1é€±é–“ï¼‰
```
1. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°
2. æ—§ãƒ„ãƒ¼ãƒ«ã‚’deprecatedãƒ•ã‚©ãƒ«ãƒ€ã¸ç§»å‹•
3. æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
4. ãƒãƒ¼ãƒ å…¨ä½“ã¸ã®é€šçŸ¥
```

---

## å®¢è¦³çš„è¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ 

### 1. è‡ªå‹•æ¯”è¼ƒæ¤œè¨¼ãƒ„ãƒ¼ãƒ«

```javascript
// tool-integration-validator.js
const fs = require('fs');
const crypto = require('crypto');
const diff = require('diff');

class ToolIntegrationValidator {
    constructor() {
        this.results = {
            timestamp: new Date().toISOString(),
            environment: {
                nodeVersion: process.version,
                platform: process.platform,
                cwd: process.cwd()
            },
            comparisons: []
        };
    }

    async validateIntegration(oldToolPath, newToolPath, testSuite) {
        console.log('ğŸ” Starting integration validation...');
        
        for (const testCase of testSuite) {
            const comparison = await this.compareToolOutputs(
                oldToolPath, 
                newToolPath, 
                testCase
            );
            
            this.logComparison(comparison);
        }
        
        return this.generateProofReport();
    }

    async compareToolOutputs(oldTool, newTool, testData) {
        const startTime = Date.now();
        
        // ä¸¡ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè¡Œ
        const oldResult = await this.runTool(oldTool, testData);
        const newResult = await this.runTool(newTool, testData);
        
        // è©³ç´°ãªæ¯”è¼ƒ
        const comparison = {
            testCase: testData.name,
            timestamp: new Date().toISOString(),
            executionTime: Date.now() - startTime,
            oldTool: {
                path: oldTool,
                output: oldResult.output,
                exitCode: oldResult.exitCode,
                duration: oldResult.duration,
                checksum: this.getChecksum(oldResult.output)
            },
            newTool: {
                path: newTool,
                output: newResult.output,
                exitCode: newResult.exitCode,
                duration: newResult.duration,
                checksum: this.getChecksum(newResult.output)
            },
            comparison: {
                outputsMatch: this.deepEqual(oldResult.output, newResult.output),
                exitCodesMatch: oldResult.exitCode === newResult.exitCode,
                performanceDiff: newResult.duration - oldResult.duration,
                textDiff: this.getTextDiff(oldResult.output, newResult.output)
            }
        };
        
        this.results.comparisons.push(comparison);
        return comparison;
    }

    getChecksum(data) {
        return crypto.createHash('sha256')
            .update(typeof data === 'string' ? data : JSON.stringify(data))
            .digest('hex');
    }

    getTextDiff(oldText, newText) {
        const oldStr = typeof oldText === 'string' ? oldText : JSON.stringify(oldText, null, 2);
        const newStr = typeof newText === 'string' ? newText : JSON.stringify(newText, null, 2);
        
        return diff.createPatch('output', oldStr, newStr);
    }

    deepEqual(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }

    async runTool(toolPath, testData) {
        const startTime = Date.now();
        const { exec } = require('child_process');
        const util = require('util');
        const execPromise = util.promisify(exec);
        
        try {
            const { stdout, stderr } = await execPromise(
                `node ${toolPath} ${testData.args || ''}`
            );
            
            return {
                output: stdout,
                error: stderr,
                exitCode: 0,
                duration: Date.now() - startTime
            };
        } catch (error) {
            return {
                output: error.stdout || '',
                error: error.stderr || error.message,
                exitCode: error.code || 1,
                duration: Date.now() - startTime
            };
        }
    }

    logComparison(comparison) {
        const status = comparison.comparison.outputsMatch ? 'âœ…' : 'âŒ';
        console.log(`${status} ${comparison.testCase}: ${
            comparison.comparison.outputsMatch ? 'PASSED' : 'FAILED'
        }`);
        
        if (!comparison.comparison.outputsMatch) {
            console.log('  Diff:', comparison.comparison.textDiff.substring(0, 200) + '...');
        }
    }

    generateProofReport() {
        const report = {
            ...this.results,
            summary: {
                totalTests: this.results.comparisons.length,
                passedTests: this.results.comparisons.filter(c => 
                    c.comparison.outputsMatch && c.comparison.exitCodesMatch
                ).length,
                failedTests: this.results.comparisons.filter(c => 
                    !c.comparison.outputsMatch || !c.comparison.exitCodesMatch
                ).length,
                averagePerformanceDiff: this.calculateAveragePerformanceDiff(),
                successRate: this.calculateSuccessRate()
            },
            certification: {
                validated: this.isFullyValidated(),
                validatedAt: new Date().toISOString(),
                validatedBy: process.env.USER || 'unknown',
                checksums: this.getAllChecksums()
            }
        };
        
        // ãƒ¬ãƒãƒ¼ãƒˆã‚’ä¿å­˜
        const filename = `integration-proof-${Date.now()}.json`;
        fs.writeFileSync(filename, JSON.stringify(report, null, 2));
        
        // äººé–“ãŒèª­ã¿ã‚„ã™ã„ã‚µãƒãƒªãƒ¼ã‚‚ç”Ÿæˆ
        this.generateHumanReadableReport(report, filename.replace('.json', '.md'));
        
        return report;
    }

    calculateAveragePerformanceDiff() {
        const diffs = this.results.comparisons.map(c => c.comparison.performanceDiff);
        return diffs.reduce((a, b) => a + b, 0) / diffs.length;
    }

    calculateSuccessRate() {
        const passed = this.results.comparisons.filter(c => 
            c.comparison.outputsMatch && c.comparison.exitCodesMatch
        ).length;
        return (passed / this.results.comparisons.length * 100).toFixed(2) + '%';
    }

    isFullyValidated() {
        return this.results.comparisons.every(c => 
            c.comparison.outputsMatch && c.comparison.exitCodesMatch
        );
    }

    getAllChecksums() {
        const checksums = {};
        this.results.comparisons.forEach(c => {
            checksums[c.testCase] = {
                old: c.oldTool.checksum,
                new: c.newTool.checksum
            };
        });
        return checksums;
    }

    generateHumanReadableReport(report, filename) {
        const markdown = `# Integration Validation Report

## Summary
- **Date**: ${report.timestamp}
- **Total Tests**: ${report.summary.totalTests}
- **Passed**: ${report.summary.passedTests}
- **Failed**: ${report.summary.failedTests}
- **Success Rate**: ${report.summary.successRate}
- **Average Performance Difference**: ${report.summary.averagePerformanceDiff.toFixed(2)}ms

## Certification
- **Fully Validated**: ${report.certification.validated ? 'YES âœ…' : 'NO âŒ'}
- **Validated By**: ${report.certification.validatedBy}
- **Validation Time**: ${report.certification.validatedAt}

## Test Details
${this.generateTestDetails(report.comparisons)}

## Checksums
\`\`\`json
${JSON.stringify(report.certification.checksums, null, 2)}
\`\`\`
`;
        
        fs.writeFileSync(filename, markdown);
    }

    generateTestDetails(comparisons) {
        return comparisons.map(c => {
            const status = c.comparison.outputsMatch ? 'âœ…' : 'âŒ';
            return `### ${status} ${c.testCase}
- Output Match: ${c.comparison.outputsMatch}
- Exit Code Match: ${c.comparison.exitCodesMatch}
- Old Tool Duration: ${c.oldTool.duration}ms
- New Tool Duration: ${c.newTool.duration}ms
- Performance Diff: ${c.comparison.performanceDiff}ms
${!c.comparison.outputsMatch ? `- Diff: See detailed diff in JSON report` : ''}
`;
        }).join('\n');
    }
}

module.exports = ToolIntegrationValidator;
```

### 2. ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«è¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// visual-proof-recorder.js
const puppeteer = require('puppeteer');
const PuppeteerScreenRecorder = require('puppeteer-screen-recorder');

class VisualProofRecorder {
    constructor() {
        this.browser = null;
        this.page = null;
        this.recorder = null;
    }

    async initialize() {
        this.browser = await puppeteer.launch({
            headless: false,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        this.page = await this.browser.newPage();
        
        // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨­å®š
        await this.page.setViewport({
            width: 1920,
            height: 1080
        });
    }

    async recordToolComparison(oldToolUrl, newToolUrl, outputPath) {
        const Config = {
            followNewTab: true,
            fps: 30,
            videoFrame: {
                width: 1920,
                height: 1080
            },
            videoCrf: 18,
            videoCodec: 'libx264',
            videoPreset: 'ultrafast',
            videoBitrate: 1000,
            autopad: {
                color: 'black'
            }
        };

        this.recorder = new PuppeteerScreenRecorder.PuppeteerScreenRecorder(this.page, Config);
        
        await this.recorder.start(outputPath);
        
        // ç”»é¢ã‚’åˆ†å‰²ã—ã¦ä¸¡ãƒ„ãƒ¼ãƒ«ã‚’è¡¨ç¤º
        await this.page.evaluate(() => {
            document.body.innerHTML = `
                <div style="display: flex; height: 100vh;">
                    <div style="flex: 1; border-right: 2px solid red;">
                        <h2 style="text-align: center; background: #f0f0f0;">æ—§ãƒ„ãƒ¼ãƒ«</h2>
                        <iframe id="old-tool" style="width: 100%; height: calc(100% - 40px); border: none;"></iframe>
                    </div>
                    <div style="flex: 1;">
                        <h2 style="text-align: center; background: #e0ffe0;">æ–°ãƒ„ãƒ¼ãƒ«</h2>
                        <iframe id="new-tool" style="width: 100%; height: calc(100% - 40px); border: none;"></iframe>
                    </div>
                </div>
                <div id="status" style="position: fixed; bottom: 10px; right: 10px; 
                    background: white; padding: 10px; border: 2px solid black; 
                    font-size: 20px; font-weight: bold;"></div>
            `;
        });
        
        // ä¸¡ãƒ„ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã¿
        await this.page.evaluate((oldUrl, newUrl) => {
            document.getElementById('old-tool').src = oldUrl;
            document.getElementById('new-tool').src = newUrl;
            document.getElementById('status').textContent = 'ğŸ”„ æ¯”è¼ƒå®Ÿè¡Œä¸­...';
        }, oldToolUrl, newToolUrl);
        
        // å®Ÿè¡Œå®Œäº†ã‚’å¾…ã¤
        await this.page.waitForTimeout(10000);
        
        // çµæœã‚’è¡¨ç¤º
        await this.page.evaluate(() => {
            document.getElementById('status').textContent = 'âœ… æ¯”è¼ƒå®Œäº†';
            document.getElementById('status').style.background = '#90EE90';
        });
        
        await this.page.waitForTimeout(2000);
        
        await this.recorder.stop();
        await this.browser.close();
        
        console.log(`ğŸ“¹ éŒ²ç”»å®Œäº†: ${outputPath}`);
    }

    async captureScreenshots(oldToolUrl, newToolUrl, outputDir) {
        await this.initialize();
        
        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆæ’®å½±
        const timestamp = Date.now();
        
        // æ—§ãƒ„ãƒ¼ãƒ«
        await this.page.goto(oldToolUrl);
        await this.page.waitForTimeout(2000);
        await this.page.screenshot({
            path: `${outputDir}/old-tool-${timestamp}.png`,
            fullPage: true
        });
        
        // æ–°ãƒ„ãƒ¼ãƒ«
        await this.page.goto(newToolUrl);
        await this.page.waitForTimeout(2000);
        await this.page.screenshot({
            path: `${outputDir}/new-tool-${timestamp}.png`,
            fullPage: true
        });
        
        await this.browser.close();
        
        console.log(`ğŸ“¸ ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜å®Œäº†: ${outputDir}`);
    }
}

module.exports = VisualProofRecorder;
```

### 3. ç¶™ç¶šçš„ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// continuous-monitoring.js
const fs = require('fs');
const path = require('path');

class ContinuousMonitor {
    constructor(config) {
        this.config = config;
        this.healthHistory = [];
        this.alertThreshold = config.alertThreshold || 3;
        this.checkInterval = config.checkInterval || 60000; // 1åˆ†
    }

    async startMonitoring() {
        console.log('ğŸ” ç¶™ç¶šçš„ç›£è¦–ã‚’é–‹å§‹ã—ã¾ã™...');
        
        this.monitoringInterval = setInterval(async () => {
            const healthCheck = await this.performHealthCheck();
            this.recordHealthCheck(healthCheck);
            
            if (!healthCheck.healthy) {
                await this.handleUnhealthyState(healthCheck);
            }
        }, this.checkInterval);
    }

    async performHealthCheck() {
        const checks = {
            timestamp: new Date().toISOString(),
            checks: {}
        };

        // å„çµ±åˆãƒ„ãƒ¼ãƒ«ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
        for (const tool of this.config.monitoredTools) {
            checks.checks[tool.name] = await this.checkTool(tool);
        }

        checks.healthy = Object.values(checks.checks).every(c => c.passed);
        return checks;
    }

    async checkTool(tool) {
        try {
            // åŸºæœ¬çš„ãªå®Ÿè¡Œãƒ†ã‚¹ãƒˆ
            const result = await this.executeTool(tool.path, tool.testArgs);
            
            // æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ã¨ã®æ¯”è¼ƒ
            const expectedChecksum = tool.expectedChecksum;
            const actualChecksum = this.calculateChecksum(result.output);
            
            return {
                passed: actualChecksum === expectedChecksum,
                executionTime: result.duration,
                actualChecksum,
                expectedChecksum,
                error: result.error
            };
        } catch (error) {
            return {
                passed: false,
                error: error.message
            };
        }
    }

    async executeTool(toolPath, args) {
        const { exec } = require('child_process');
        const util = require('util');
        const execPromise = util.promisify(exec);
        
        const startTime = Date.now();
        
        try {
            const { stdout, stderr } = await execPromise(`node ${toolPath} ${args}`);
            return {
                output: stdout,
                error: stderr,
                duration: Date.now() - startTime
            };
        } catch (error) {
            return {
                output: '',
                error: error.message,
                duration: Date.now() - startTime
            };
        }
    }

    calculateChecksum(data) {
        const crypto = require('crypto');
        return crypto.createHash('sha256')
            .update(data)
            .digest('hex');
    }

    recordHealthCheck(healthCheck) {
        this.healthHistory.push(healthCheck);
        
        // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜éŒ²
        const logFile = path.join(this.config.logDir, 'health-monitoring.log');
        fs.appendFileSync(logFile, JSON.stringify(healthCheck) + '\n');
        
        // å±¥æ­´ã‚’åˆ¶é™ï¼ˆãƒ¡ãƒ¢ãƒªç¯€ç´„ï¼‰
        if (this.healthHistory.length > 1000) {
            this.healthHistory = this.healthHistory.slice(-500);
        }
    }

    async handleUnhealthyState(healthCheck) {
        const failedTools = Object.entries(healthCheck.checks)
            .filter(([_, check]) => !check.passed)
            .map(([name, _]) => name);
        
        console.error(`âš ï¸ ç•°å¸¸æ¤œå‡º: ${failedTools.join(', ')}`);
        
        // é€£ç¶šå¤±æ•—å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        const recentFailures = this.countRecentFailures(failedTools);
        
        if (recentFailures >= this.alertThreshold) {
            console.error(`ğŸš¨ é–¾å€¤è¶…éï¼è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ`);
            
            for (const toolName of failedTools) {
                await this.rollbackTool(toolName);
            }
            
            // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
            await this.sendAlert({
                type: 'AUTOMATIC_ROLLBACK',
                tools: failedTools,
                healthCheck
            });
        }
    }

    countRecentFailures(toolNames) {
        // ç›´è¿‘ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‹ã‚‰é€£ç¶šå¤±æ•—å›æ•°ã‚’è¨ˆç®—
        let count = 0;
        
        for (let i = this.healthHistory.length - 1; i >= 0; i--) {
            const check = this.healthHistory[i];
            const failed = toolNames.some(name => 
                check.checks[name] && !check.checks[name].passed
            );
            
            if (failed) {
                count++;
            } else {
                break;
            }
        }
        
        return count;
    }

    async rollbackTool(toolName) {
        const rollbackManager = require('./rollback-manager');
        return await rollbackManager.rollback(toolName);
    }

    async sendAlert(alert) {
        // ã‚¢ãƒ©ãƒ¼ãƒˆãƒ­ã‚°è¨˜éŒ²
        const alertFile = path.join(this.config.logDir, 'alerts.log');
        fs.appendFileSync(alertFile, JSON.stringify({
            ...alert,
            timestamp: new Date().toISOString()
        }) + '\n');
        
        // å®Ÿéš›ã®ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡ï¼ˆãƒ¡ãƒ¼ãƒ«ã€Slackç­‰ï¼‰ã¯ã“ã“ã«å®Ÿè£…
        console.log(`ğŸ“§ ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡: ${JSON.stringify(alert, null, 2)}`);
    }

    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            console.log('ğŸ›‘ ç›£è¦–ã‚’åœæ­¢ã—ã¾ã—ãŸ');
        }
    }
}

module.exports = ContinuousMonitor;
```

---

## å…·ä½“çš„ãªçµ±åˆä¾‹

### ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãƒã‚§ãƒƒã‚«ãƒ¼ã®çµ±åˆ

#### 1. çµ±åˆãƒ„ãƒ¼ãƒ«ã®æ§‹é€ 
```javascript
// unified-display-checker.js
const fs = require('fs');
const { JSDOM } = require('jsdom');

class UnifiedDisplayChecker {
    constructor(options = {}) {
        this.mode = options.mode || 'standard';
        this.verbose = options.verbose || false;
        this.legacy = options.legacy || false;
        
        // ãƒ¢ãƒ¼ãƒ‰åˆ¥ã®è¨­å®š
        this.modeConfigs = {
            'simple': {
                checkHidden: true,
                checkDisplay: true,
                checkVisibility: true,
                checkOpacity: true,
                outputFormat: 'simple'
            },
            'universal': {
                checkHidden: true,
                checkDisplay: true,
                checkVisibility: true,
                checkOpacity: true,
                checkPosition: true,
                outputFormat: 'detailed'
            },
            'jsdom': {
                targetElements: ['#weight-input', '#weight-display', '.weight-chart'],
                checkHidden: true,
                checkDisplay: true,
                outputFormat: 'weight-specific'
            },
            'standard': {
                checkAll: true,
                outputFormat: 'comprehensive'
            }
        };
    }

    async check(htmlPath, options = {}) {
        // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—§ãƒ„ãƒ¼ãƒ«ã¨å®Œå…¨äº’æ›ï¼‰
        if (this.legacy) {
            return this.legacyCheck(htmlPath, options);
        }

        const config = { ...this.modeConfigs[this.mode], ...options };
        const startTime = Date.now();

        try {
            // HTMLãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
            const html = fs.readFileSync(htmlPath, 'utf8');
            const dom = new JSDOM(html);
            const document = dom.window.document;

            const results = {
                file: htmlPath,
                mode: this.mode,
                timestamp: new Date().toISOString(),
                checks: [],
                summary: {
                    totalElements: 0,
                    visibleElements: 0,
                    hiddenElements: 0,
                    issues: []
                }
            };

            // ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
            const elements = this.getTargetElements(document, config);
            
            for (const element of elements) {
                const elementCheck = await this.checkElement(element, config);
                results.checks.push(elementCheck);
                
                this.updateSummary(results.summary, elementCheck);
            }

            results.executionTime = Date.now() - startTime;
            
            // å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            return this.formatOutput(results, config.outputFormat);
            
        } catch (error) {
            return {
                error: error.message,
                file: htmlPath,
                mode: this.mode
            };
        }
    }

    getTargetElements(document, config) {
        if (config.targetElements) {
            // ç‰¹å®šè¦ç´ ã®ã¿ï¼ˆjsdomãƒ¢ãƒ¼ãƒ‰ç­‰ï¼‰
            return config.targetElements.flatMap(selector => 
                Array.from(document.querySelectorAll(selector))
            );
        }
        
        // å…¨è¦ç´ 
        return Array.from(document.querySelectorAll('*'));
    }

    async checkElement(element, config) {
        const check = {
            tagName: element.tagName,
            id: element.id,
            className: element.className,
            checks: {}
        };

        const computedStyle = element.ownerDocument.defaultView.getComputedStyle(element);

        if (config.checkHidden || config.checkAll) {
            check.checks.hidden = element.classList.contains('hidden');
        }

        if (config.checkDisplay || config.checkAll) {
            check.checks.display = computedStyle.display;
            check.checks.displayNone = computedStyle.display === 'none';
        }

        if (config.checkVisibility || config.checkAll) {
            check.checks.visibility = computedStyle.visibility;
            check.checks.visibilityHidden = computedStyle.visibility === 'hidden';
        }

        if (config.checkOpacity || config.checkAll) {
            check.checks.opacity = computedStyle.opacity;
            check.checks.transparent = parseFloat(computedStyle.opacity) === 0;
        }

        if (config.checkPosition || config.checkAll) {
            check.checks.position = computedStyle.position;
            check.checks.offScreen = this.isOffScreen(element, computedStyle);
        }

        // ç·åˆçš„ãªå¯è¦–æ€§åˆ¤å®š
        check.isVisible = this.isElementVisible(check);

        return check;
    }

    isOffScreen(element, computedStyle) {
        const rect = element.getBoundingClientRect();
        return (
            rect.bottom < 0 ||
            rect.right < 0 ||
            rect.left > element.ownerDocument.defaultView.innerWidth ||
            rect.top > element.ownerDocument.defaultView.innerHeight
        );
    }

    isElementVisible(check) {
        return !(
            check.checks.hidden ||
            check.checks.displayNone ||
            check.checks.visibilityHidden ||
            check.checks.transparent ||
            check.checks.offScreen
        );
    }

    updateSummary(summary, elementCheck) {
        summary.totalElements++;
        
        if (elementCheck.isVisible) {
            summary.visibleElements++;
        } else {
            summary.hiddenElements++;
            
            // å•é¡Œã®è©³ç´°ã‚’è¨˜éŒ²
            const issue = {
                element: `${elementCheck.tagName}${elementCheck.id ? '#' + elementCheck.id : ''}`,
                reasons: []
            };
            
            if (elementCheck.checks.hidden) issue.reasons.push('has-hidden-class');
            if (elementCheck.checks.displayNone) issue.reasons.push('display-none');
            if (elementCheck.checks.visibilityHidden) issue.reasons.push('visibility-hidden');
            if (elementCheck.checks.transparent) issue.reasons.push('opacity-0');
            if (elementCheck.checks.offScreen) issue.reasons.push('off-screen');
            
            summary.issues.push(issue);
        }
    }

    formatOutput(results, format) {
        switch (format) {
            case 'simple':
                return this.formatSimple(results);
            case 'detailed':
                return this.formatDetailed(results);
            case 'weight-specific':
                return this.formatWeightSpecific(results);
            case 'comprehensive':
            default:
                return results;
        }
    }

    formatSimple(results) {
        return {
            visible: results.summary.visibleElements,
            hidden: results.summary.hiddenElements,
            total: results.summary.totalElements,
            issues: results.summary.issues.length
        };
    }

    formatDetailed(results) {
        return {
            file: results.file,
            summary: results.summary,
            topIssues: results.summary.issues.slice(0, 10)
        };
    }

    formatWeightSpecific(results) {
        const weightElements = results.checks.filter(c => 
            c.id.includes('weight') || c.className.includes('weight')
        );
        
        return {
            weightElementsTotal: weightElements.length,
            weightElementsVisible: weightElements.filter(e => e.isVisible).length,
            issues: weightElements.filter(e => !e.isVisible).map(e => ({
                element: e.id || e.className,
                reasons: Object.entries(e.checks)
                    .filter(([_, value]) => value === true)
                    .map(([key, _]) => key)
            }))
        };
    }

    // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ¢ãƒ¼ãƒ‰å®Ÿè£…ï¼ˆæ—§ãƒ„ãƒ¼ãƒ«ã¨ã®å®Œå…¨äº’æ›æ€§ï¼‰
    async legacyCheck(htmlPath, options) {
        // æ—§ãƒ„ãƒ¼ãƒ«ã®å‡ºåŠ›å½¢å¼ã‚’å®Œå…¨ã«å†ç¾
        const legacyMode = options.legacyTool || 'simple-display-checker';
        
        switch (legacyMode) {
            case 'simple-display-checker':
                return this.legacySimpleCheck(htmlPath);
            case 'universal-display-checker':
                return this.legacyUniversalCheck(htmlPath);
            case 'jsdom_display_checker':
                return this.legacyJsdomCheck(htmlPath);
            default:
                throw new Error(`Unknown legacy tool: ${legacyMode}`);
        }
    }

    async legacySimpleCheck(htmlPath) {
        // simple-display-checker.jsã®å‡ºåŠ›å½¢å¼ã‚’å®Œå…¨å†ç¾
        const results = await this.check(htmlPath, { mode: 'simple' });
        
        return {
            "Display State Analysis": {
                "Total Elements": results.total,
                "Visible Elements": results.visible,
                "Hidden Elements": results.hidden
            },
            "Issues Found": results.issues
        };
    }

    async legacyUniversalCheck(htmlPath) {
        // universal-display-checker.jsã®å‡ºåŠ›å½¢å¼ã‚’å®Œå…¨å†ç¾
        const results = await this.check(htmlPath, { mode: 'universal' });
        
        return {
            file: results.file,
            analysis: {
                totalElements: results.summary.totalElements,
                visibleElements: results.summary.visibleElements,
                hiddenElements: results.summary.hiddenElements
            },
            issues: results.topIssues
        };
    }

    async legacyJsdomCheck(htmlPath) {
        // jsdom_display_checker.jsã®å‡ºåŠ›å½¢å¼ã‚’å®Œå…¨å†ç¾
        const results = await this.check(htmlPath, { mode: 'jsdom' });
        
        return {
            "Weight Management Display Check": {
                "Total Weight Elements": results.weightElementsTotal,
                "Visible Weight Elements": results.weightElementsVisible,
                "Hidden Weight Elements": results.weightElementsTotal - results.weightElementsVisible
            },
            "Hidden Element Details": results.issues
        };
    }
}

// CLIå¯¾å¿œ
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.length < 1) {
        console.log('Usage: node unified-display-checker.js <html-file> [options]');
        console.log('Options:');
        console.log('  --mode <mode>     : simple, universal, jsdom, standard (default: standard)');
        console.log('  --legacy <tool>   : Run in legacy mode for backward compatibility');
        console.log('  --verbose         : Verbose output');
        process.exit(1);
    }

    const htmlPath = args[0];
    const options = {};

    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³è§£æ
    for (let i = 1; i < args.length; i += 2) {
        const key = args[i].replace('--', '');
        options[key] = args[i + 1];
    }

    const checker = new UnifiedDisplayChecker(options);
    
    checker.check(htmlPath, options).then(results => {
        console.log(JSON.stringify(results, null, 2));
    }).catch(error => {
        console.error('Error:', error.message);
        process.exit(1);
    });
}

module.exports = UnifiedDisplayChecker;
```

#### 2. ç§»è¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```javascript
// migrate-display-checkers.js
const fs = require('fs');
const path = require('path');

async function migrateDisplayCheckers() {
    const migrations = [
        {
            old: 'simple-display-checker.js',
            new: 'unified-display-checker.js --mode simple',
            packageJsonScript: 'test:display:simple'
        },
        {
            old: 'universal-display-checker.js',
            new: 'unified-display-checker.js --mode universal',
            packageJsonScript: 'test:display:universal'
        },
        {
            old: 'jsdom_display_checker.js',
            new: 'unified-display-checker.js --mode jsdom',
            packageJsonScript: 'test:display:jsdom'
        }
    ];

    console.log('ğŸ”„ ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ãƒã‚§ãƒƒã‚«ãƒ¼ã®ç§»è¡Œã‚’é–‹å§‹ã—ã¾ã™...\n');

    for (const migration of migrations) {
        console.log(`ğŸ“‹ ${migration.old} â†’ unified-display-checker.js`);
        
        // package.jsonã‚’æ›´æ–°
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        if (packageJson.scripts[migration.packageJsonScript]) {
            // æ—§ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
            packageJson.scripts[`${migration.packageJsonScript}:legacy`] = 
                packageJson.scripts[migration.packageJsonScript];
            
            // æ–°ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«æ›´æ–°
            packageJson.scripts[migration.packageJsonScript] = 
                `node ${migration.new}`;
            
            console.log(`  âœ… package.jsonæ›´æ–°: ${migration.packageJsonScript}`);
        }
        
        // æ—§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ deprecated ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•
        const deprecatedDir = path.join('development/tools/testing/deprecated');
        if (!fs.existsSync(deprecatedDir)) {
            fs.mkdirSync(deprecatedDir, { recursive: true });
        }
        
        const oldPath = path.join('development/tools/testing', migration.old);
        const newPath = path.join(deprecatedDir, migration.old);
        
        if (fs.existsSync(oldPath)) {
            fs.renameSync(oldPath, newPath);
            console.log(`  âœ… æ—§ãƒ„ãƒ¼ãƒ«ã‚’deprecatedã«ç§»å‹•: ${migration.old}`);
        }
    }

    // package.json ã‚’ä¿å­˜
    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
    console.log('\nâœ… ç§»è¡Œå®Œäº†ï¼');
}

// å®Ÿè¡Œ
migrateDisplayCheckers().catch(console.error);
```

---

## ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ—ãƒ©ãƒ³

### è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// rollback-manager.js
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class RollbackManager {
    constructor() {
        this.backupDir = './tool-backups';
        this.versionFile = './tool-versions.json';
        this.rollbackLog = './rollback-history.log';
        
        this.ensureDirectories();
    }

    ensureDirectories() {
        if (!fs.existsSync(this.backupDir)) {
            fs.mkdirSync(this.backupDir, { recursive: true });
        }
        
        if (!fs.existsSync(this.versionFile)) {
            fs.writeFileSync(this.versionFile, '{}');
        }
    }

    // çµ±åˆå‰ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    async createBackup(toolPath, metadata = {}) {
        const toolName = path.basename(toolPath);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupName = `${toolName}-${timestamp}`;
        const backupPath = path.join(this.backupDir, backupName);

        console.log(`ğŸ“¦ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: ${toolName}`);

        // ãƒ„ãƒ¼ãƒ«æœ¬ä½“ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
        fs.copyFileSync(toolPath, path.join(backupPath, toolName));

        // é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆè¨­å®šã€ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç­‰ï¼‰
        const relatedFiles = this.findRelatedFiles(toolPath);
        for (const file of relatedFiles) {
            const relativePath = path.relative(path.dirname(toolPath), file);
            const destPath = path.join(backupPath, relativePath);
            
            fs.mkdirSync(path.dirname(destPath), { recursive: true });
            fs.copyFileSync(file, destPath);
        }

        // Gitæƒ…å ±ã®è¨˜éŒ²
        const gitInfo = {
            commit: execSync('git rev-parse HEAD').toString().trim(),
            branch: execSync('git branch --show-current').toString().trim(),
            uncommittedChanges: execSync('git status --porcelain').toString()
        };

        // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜
        const backupInfo = {
            toolName,
            toolPath,
            timestamp,
            backupPath,
            gitInfo,
            metadata,
            relatedFiles: relatedFiles.map(f => path.relative(process.cwd(), f))
        };

        fs.writeFileSync(
            path.join(backupPath, 'backup-info.json'),
            JSON.stringify(backupInfo, null, 2)
        );

        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
        this.updateVersionFile(toolName, backupInfo);

        console.log(`âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†: ${backupPath}`);
        return backupPath;
    }

    findRelatedFiles(toolPath) {
        const toolDir = path.dirname(toolPath);
        const toolName = path.basename(toolPath, '.js');
        const related = [];

        // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
        const configPath = path.join(toolDir, `${toolName}.config.json`);
        if (fs.existsSync(configPath)) {
            related.push(configPath);
        }

        // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
        const testDataPath = path.join(toolDir, 'test-data', toolName);
        if (fs.existsSync(testDataPath)) {
            related.push(testDataPath);
        }

        // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
        const docPath = path.join(toolDir, `${toolName}.md`);
        if (fs.existsSync(docPath)) {
            related.push(docPath);
        }

        return related;
    }

    updateVersionFile(toolName, backupInfo) {
        const versions = JSON.parse(fs.readFileSync(this.versionFile, 'utf8'));
        
        if (!versions[toolName]) {
            versions[toolName] = [];
        }

        versions[toolName].push({
            version: versions[toolName].length + 1,
            timestamp: backupInfo.timestamp,
            backupPath: backupInfo.backupPath,
            gitCommit: backupInfo.gitInfo.commit
        });

        fs.writeFileSync(this.versionFile, JSON.stringify(versions, null, 2));
    }

    // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ
    async rollback(toolName, version = 'latest') {
        console.log(`ğŸ”„ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯é–‹å§‹: ${toolName} (version: ${version})`);

        const versions = JSON.parse(fs.readFileSync(this.versionFile, 'utf8'));
        
        if (!versions[toolName] || versions[toolName].length === 0) {
            throw new Error(`No backup found for tool: ${toolName}`);
        }

        let backupInfo;
        
        if (version === 'latest') {
            backupInfo = versions[toolName][versions[toolName].length - 1];
        } else if (typeof version === 'number') {
            backupInfo = versions[toolName].find(v => v.version === version);
        } else {
            // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§æ¤œç´¢
            backupInfo = versions[toolName].find(v => v.timestamp === version);
        }

        if (!backupInfo) {
            throw new Error(`Backup version not found: ${version}`);
        }

        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±ã®èª­ã¿è¾¼ã¿
        const fullBackupInfo = JSON.parse(
            fs.readFileSync(path.join(backupInfo.backupPath, 'backup-info.json'), 'utf8')
        );

        // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
        const safetyBackup = await this.createSafetyBackup(fullBackupInfo.toolPath);

        try {
            // ãƒ„ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å…ƒ
            fs.copyFileSync(
                path.join(backupInfo.backupPath, toolName),
                fullBackupInfo.toolPath
            );

            // é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å…ƒ
            for (const relatedFile of fullBackupInfo.relatedFiles) {
                const sourcePath = path.join(backupInfo.backupPath, path.basename(relatedFile));
                const destPath = path.resolve(relatedFile);
                
                if (fs.existsSync(sourcePath)) {
                    fs.copyFileSync(sourcePath, destPath);
                }
            }

            // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨˜éŒ²
            this.logRollback({
                toolName,
                version: backupInfo.version,
                timestamp: new Date().toISOString(),
                reason: 'Manual rollback requested',
                success: true,
                restoredFrom: backupInfo.backupPath
            });

            console.log(`âœ… ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆåŠŸ: ${toolName} (version ${backupInfo.version})`);
            
            // ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
            this.removeSafetyBackup(safetyBackup);
            
            return true;

        } catch (error) {
            console.error(`âŒ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—: ${error.message}`);
            
            // ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
            await this.restoreFromSafetyBackup(safetyBackup);
            
            this.logRollback({
                toolName,
                version: backupInfo.version,
                timestamp: new Date().toISOString(),
                reason: 'Manual rollback requested',
                success: false,
                error: error.message
            });
            
            throw error;
        }
    }

    async createSafetyBackup(toolPath) {
        const safetyPath = `${toolPath}.safety-${Date.now()}`;
        fs.copyFileSync(toolPath, safetyPath);
        return safetyPath;
    }

    async restoreFromSafetyBackup(safetyPath) {
        const originalPath = safetyPath.replace(/\.safety-\d+$/, '');
        fs.copyFileSync(safetyPath, originalPath);
        fs.unlinkSync(safetyPath);
    }

    removeSafetyBackup(safetyPath) {
        if (fs.existsSync(safetyPath)) {
            fs.unlinkSync(safetyPath);
        }
    }

    logRollback(info) {
        const logEntry = `${JSON.stringify(info)}\n`;
        fs.appendFileSync(this.rollbackLog, logEntry);
    }

    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§è¡¨ç¤º
    listBackups(toolName = null) {
        const versions = JSON.parse(fs.readFileSync(this.versionFile, 'utf8'));
        
        if (toolName) {
            return versions[toolName] || [];
        }
        
        return versions;
    }

    // å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    async cleanupOldBackups(retentionDays = 30) {
        console.log(`ğŸ§¹ ${retentionDays}æ—¥ä»¥ä¸Šå‰ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­...`);

        const now = Date.now();
        const retentionMs = retentionDays * 24 * 60 * 60 * 1000;
        const versions = JSON.parse(fs.readFileSync(this.versionFile, 'utf8'));
        let cleaned = 0;

        for (const [toolName, backups] of Object.entries(versions)) {
            const recentBackups = backups.filter(backup => {
                const backupTime = new Date(backup.timestamp).getTime();
                const age = now - backupTime;
                
                if (age > retentionMs) {
                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‰Šé™¤
                    if (fs.existsSync(backup.backupPath)) {
                        fs.rmSync(backup.backupPath, { recursive: true });
                        cleaned++;
                    }
                    return false;
                }
                
                return true;
            });

            versions[toolName] = recentBackups;
        }

        fs.writeFileSync(this.versionFile, JSON.stringify(versions, null, 2));
        console.log(`âœ… ${cleaned}å€‹ã®å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
    }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
const rollbackManager = new RollbackManager();

module.exports = rollbackManager;
```

---

## ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

### ãƒ„ãƒ¼ãƒ«çµ±åˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```markdown
# ãƒ„ãƒ¼ãƒ«çµ±åˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ - [ãƒ„ãƒ¼ãƒ«å]

**çµ±åˆé–‹å§‹æ—¥**: ____________________  
**æ‹…å½“è€…**: ____________________  
**å¯¾è±¡ãƒ„ãƒ¼ãƒ«**: ____________________  

## Phase 1: æº–å‚™ âœ…

### äº‹å‰æº–å‚™
- [ ] çµ±åˆå¯¾è±¡ãƒ„ãƒ¼ãƒ«ã®ä¸€è¦§ä½œæˆ
  - [ ] [æ—§ãƒ„ãƒ¼ãƒ«1å]: ____________________
  - [ ] [æ—§ãƒ„ãƒ¼ãƒ«2å]: ____________________
  - [ ] [æ—§ãƒ„ãƒ¼ãƒ«3å]: ____________________
- [ ] å„ãƒ„ãƒ¼ãƒ«ã®æ©Ÿèƒ½ä»•æ§˜æ›¸ä½œæˆ
- [ ] ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä¸€è¦§ã®ä½œæˆ
- [ ] æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ã®ã‚µãƒ³ãƒ—ãƒ«åé›†

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- [ ] Gitã‚¿ã‚°ä½œæˆ: `git tag pre-integration-[tool-name]-[date]`
- [ ] ãƒ„ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†
- [ ] é–¢é€£è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ¤œè¨¼ï¼ˆå¾©å…ƒå¯èƒ½ã‹ç¢ºèªï¼‰

## Phase 2: é–‹ç™º âœ…

### çµ±åˆãƒ„ãƒ¼ãƒ«é–‹ç™º
- [ ] çµ±åˆãƒ„ãƒ¼ãƒ«ã®åŸºæœ¬æ§‹é€ å®Ÿè£…
- [ ] å„ãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…
  - [ ] ãƒ¢ãƒ¼ãƒ‰1: ____________________
  - [ ] ãƒ¢ãƒ¼ãƒ‰2: ____________________
  - [ ] ãƒ¢ãƒ¼ãƒ‰3: ____________________
- [ ] ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾Œæ–¹äº’æ›ï¼‰å®Ÿè£…
- [ ] CLIã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…

### ãƒ†ã‚¹ãƒˆä½œæˆ
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆä½œæˆ
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆä½œæˆ
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆä½œæˆ
- [ ] å‡ºåŠ›æ¯”è¼ƒãƒ†ã‚¹ãƒˆä½œæˆ

### ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
- [ ] ã‚»ãƒ«ãƒ•ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†
- [ ] ãƒ”ã‚¢ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿæ–½
- [ ] ãƒ¬ãƒ“ãƒ¥ãƒ¼æŒ‡æ‘˜äº‹é …ã®ä¿®æ­£

## Phase 3: ä¸¦è¡Œé‹ç”¨ âœ…

### æ¯”è¼ƒæ¤œè¨¼ï¼ˆæœ€ä½1é€±é–“ï¼‰
- [ ] Day 1: ä¸¦è¡Œå®Ÿè¡Œé–‹å§‹
  - [ ] è‡ªå‹•æ¯”è¼ƒã‚¹ã‚¯ãƒªãƒ—ãƒˆè¨­å®š
  - [ ] å®Ÿè¡Œãƒ­ã‚°è¨˜éŒ²é–‹å§‹
- [ ] Day 2-6: ç¶™ç¶šç›£è¦–
  - [ ] æ—¥æ¬¡ãƒ¬ãƒãƒ¼ãƒˆç¢ºèª
  - [ ] å·®åˆ†åˆ†æ
  - [ ] å•é¡Œç‚¹ã®è¨˜éŒ²
- [ ] Day 7: è©•ä¾¡
  - [ ] æˆåŠŸç‡: ______ %
  - [ ] å¹³å‡ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å·®: ______ ms
  - [ ] å•é¡Œä»¶æ•°: ______

### è¨¼è·¡åé›†
- [ ] è‡ªå‹•æ¯”è¼ƒãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
- [ ] ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ/å‹•ç”»æ’®å½±
- [ ] ãƒã‚§ãƒƒã‚¯ã‚µãƒ ä¸€è‡´ã®ç¢ºèª
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²

## Phase 4: æ®µéšçš„åˆ‡ã‚Šæ›¿ãˆ âœ…

### ç§»è¡Œã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
- [ ] Week 1: 10%ã®ãƒ†ã‚¹ãƒˆã‚’æ–°ãƒ„ãƒ¼ãƒ«ã§å®Ÿè¡Œ
  - [ ] å¯¾è±¡ãƒ†ã‚¹ãƒˆé¸å®š
  - [ ] package.jsonæ›´æ–°
  - [ ] å®Ÿè¡Œç¢ºèª
- [ ] Week 2: 50%ã®ãƒ†ã‚¹ãƒˆã‚’æ–°ãƒ„ãƒ¼ãƒ«ã§å®Ÿè¡Œ
  - [ ] è¿½åŠ ãƒ†ã‚¹ãƒˆé¸å®š
  - [ ] ç›£è¦–å¼·åŒ–
  - [ ] ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†
- [ ] Week 3: 100%ã®ãƒ†ã‚¹ãƒˆã‚’æ–°ãƒ„ãƒ¼ãƒ«ã§å®Ÿè¡Œ
  - [ ] å®Œå…¨ç§»è¡Œ
  - [ ] æ—§ãƒ„ãƒ¼ãƒ«ç„¡åŠ¹åŒ–
  - [ ] æœ€çµ‚ç¢ºèª

### ç›£è¦–æœŸé–“ï¼ˆ1é€±é–“ï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ç‡ç›£è¦–
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†

## Phase 5: å®Œäº† âœ…

### æ–‡æ›¸æ›´æ–°
- [ ] README.mdæ›´æ–°
- [ ] é–‹ç™ºè€…ã‚¬ã‚¤ãƒ‰æ›´æ–°
- [ ] APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°
- [ ] ç§»è¡Œã‚¬ã‚¤ãƒ‰ä½œæˆ

### ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- [ ] æ—§ãƒ„ãƒ¼ãƒ«ã‚’deprecatedãƒ•ã‚©ãƒ«ãƒ€ã¸ç§»å‹•
- [ ] ä¸è¦ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
- [ ] package.jsonã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—

### é€šçŸ¥ãƒ»å…±æœ‰
- [ ] ãƒãƒ¼ãƒ å…¨ä½“ã¸ã®é€šçŸ¥
- [ ] ç§»è¡Œå®Œäº†ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
- [ ] ãƒŠãƒ¬ãƒƒã‚¸å…±æœ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Ÿæ–½

### ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ï¼ˆ1ãƒ¶æœˆå¾Œï¼‰
- [ ] æ—§ãƒ„ãƒ¼ãƒ«ã®æœ€çµ‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®æ•´ç†
- [ ] æœ€çµ‚æ–‡æ›¸åŒ–

## æ‰¿èªãƒ»ã‚µã‚¤ãƒ³ã‚ªãƒ•

**æŠ€è¡“ãƒªãƒ¼ãƒ‰æ‰¿èª**: ____________________ æ—¥ä»˜: ______  
**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼æ‰¿èª**: ____________________ æ—¥ä»˜: ______  
**å“è³ªä¿è¨¼æ‰¿èª**: ____________________ æ—¥ä»˜: ______  

---

## å•é¡Œãƒ»èª²é¡Œè¨˜éŒ²

### ç™ºç”Ÿã—ãŸå•é¡Œ
1. **å•é¡Œ**: ____________________
   - **ç™ºç”Ÿæ—¥**: ______
   - **å½±éŸ¿**: ____________________
   - **å¯¾å¿œ**: ____________________
   - **è§£æ±ºæ—¥**: ______

2. **å•é¡Œ**: ____________________
   - **ç™ºç”Ÿæ—¥**: ______
   - **å½±éŸ¿**: ____________________
   - **å¯¾å¿œ**: ____________________
   - **è§£æ±ºæ—¥**: ______

### å­¦ã‚“ã ã“ã¨
1. ____________________
2. ____________________
3. ____________________

### ä»Šå¾Œã®æ”¹å–„ç‚¹
1. ____________________
2. ____________________
3. ____________________
```

---

## ã¾ã¨ã‚

ã“ã®æ–¹é‡æ›¸ã«å¾“ã£ã¦å®‰å…¨ã«ãƒ„ãƒ¼ãƒ«çµ±åˆã‚’é€²ã‚ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ãŒå®Ÿç¾ã§ãã¾ã™ï¼š

1. **æ©Ÿèƒ½ã®å®Œå…¨ä¿æŒ** - æ—¢å­˜æ©Ÿèƒ½ã‚’100%ç¶­æŒã—ãŸã¾ã¾çµ±åˆ
2. **å®¢è¦³çš„è¨¼æ˜** - è‡ªå‹•ãƒ†ã‚¹ãƒˆã¨è¦–è¦šçš„è¨¼æ‹ ã«ã‚ˆã‚Šè¨¼æ˜
3. **ãƒªã‚¹ã‚¯ã®æœ€å°åŒ–** - æ®µéšçš„ç§»è¡Œã¨å³åº§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
4. **é€æ˜æ€§ã®ç¢ºä¿** - å…¨éç¨‹ã®è¨˜éŒ²ã¨å…±æœ‰
5. **ç¶™ç¶šçš„æ”¹å–„** - ç›£è¦–ã¨æœ€é©åŒ–ã®ä»•çµ„ã¿

çµ±åˆã«ã‚ˆã‚Šã€ãƒ„ãƒ¼ãƒ«æ•°ã‚’ç´„60%å‰Šæ¸›ã—ãªãŒã‚‰ã€ä¿å®ˆæ€§ã¨ä½¿ã„ã‚„ã™ã•ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

---

## ğŸ“ ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè©•ä¾¡æ„è¦‹

**è©•ä¾¡æ—¥æ™‚**: 2025-01-20 21:45:00  
**è©•ä¾¡è€…**: General-purpose ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

### ç·åˆè©•ä¾¡ï¼š8.5/10

#### ğŸŒŸ ä¸»ãªå¼·ã¿ï¼ˆãƒˆãƒƒãƒ—3ï¼‰

1. **åŒ…æ‹¬çš„ãªå®‰å…¨ç¶²** - è¤‡æ•°å±¤ã®æ¤œè¨¼ã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã€ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿæ§‹ã«ã‚ˆã‚Šæ—¢å­˜æ©Ÿèƒ½ã¸ã®ãƒªã‚¹ã‚¯ãŒã‚¼ãƒ­
2. **å®Ÿè·µçš„ãªå®Ÿè£…ä¾‹** - ã™ãã«ä½¿ãˆã‚‹ã‚³ãƒ¼ãƒ‰ãŒæä¾›ã•ã‚Œã¦ãŠã‚Šã€ç†è«–ã ã‘ã§ãªãå®Ÿç”¨çš„
3. **å®¢è¦³çš„ãªè¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ ** - æ˜ç¢ºã§æ¸¬å®šå¯èƒ½ãªæ¤œè¨¼æ–¹æ³•ã«ã‚ˆã‚Šã€çµ±åˆã®æˆåŠŸãŒæ›–æ˜§ã•ãªãè¨¼æ˜ã§ãã‚‹

#### ğŸ”§ æ”¹å–„ãŒå¿…è¦ãªé ˜åŸŸï¼ˆãƒˆãƒƒãƒ—3ï¼‰

1. **ãƒªã‚½ãƒ¼ã‚¹ã®æœ€é©åŒ–** - ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ„ãƒ¼ãƒ«ã«ã¯éå‰°è¨­è¨ˆã®å¯èƒ½æ€§ã€‚è¤‡é›‘åº¦ã«å¿œã˜ãŸæŸ”è»Ÿæ€§ãŒå¿…è¦
2. **ãƒãƒ¼ãƒ ã¨ãƒ—ãƒ­ã‚»ã‚¹ã®çµ±åˆ** - äººçš„è¦å› ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã€æ—¢å­˜é–‹ç™ºãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã¨ã®çµ±åˆã«ã‚ˆã‚Šç„¦ç‚¹ãŒå¿…è¦
3. **ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã®å‡¦ç†** - éæ±ºå®šçš„å‡ºåŠ›ã€çŠ¶æ…‹ç§»è¡Œã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …ã®ã‚«ãƒãƒ¬ãƒƒã‚¸å‘ä¸ŠãŒå¿…è¦

#### å„é …ç›®ã®è©³ç´°è©•ä¾¡

- **å®Œå…¨æ€§**: 9/10 - éå¸¸ã«åŒ…æ‹¬çš„ã ãŒã€CI/CDçµ±åˆã‚„å¤–éƒ¨ä¾å­˜é–¢ä¿‚ã®æ‰±ã„ãŒä¸è¶³
- **å®Ÿç”¨æ€§**: 7/10 - 6-8é€±é–“ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãŒä¿å®ˆçš„ã™ãã‚‹å¯èƒ½æ€§
- **å®‰å…¨å¯¾ç­–**: 10/10 - å„ªã‚ŒãŸå¤šå±¤é˜²å¾¡ã‚·ã‚¹ãƒ†ãƒ 
- **è¨¼æ˜ã‚·ã‚¹ãƒ†ãƒ **: 9/10 - å¼·åŠ›ã ãŒã€éæ±ºå®šçš„å‡ºåŠ›ã®æ‰±ã„ãŒæœªå¯¾å¿œ
- **ã‚³ãƒ¼ãƒ‰å“è³ª**: 8/10 - è‰¯å¥½ã ãŒã€TypeScriptå¯¾å¿œã‚„å…¥åŠ›æ¤œè¨¼ã®æ”¹å–„ä½™åœ°ã‚ã‚Š
- **ãƒªã‚¹ã‚¯ç®¡ç†**: 8/10 - ä¸»è¦ãƒªã‚¹ã‚¯ã¯å¯¾å¿œæ¸ˆã¿ã ãŒã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚„ãƒãƒ¼ãƒ å½±éŸ¿ã®è€ƒæ…®ä¸è¶³

#### ä¸è¶³ã—ã¦ã„ã‚‹é‡è¦ãªè¦ç´ 

1. **æ–‡æ›¸ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°** - ãƒ•ã‚§ãƒ¼ã‚ºé–“ã§ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ç®¡ç†æ–¹æ³•
2. **ãƒãƒ¼ãƒ ç ”ä¿®è¨ˆç”»** - æ–°çµ±åˆãƒ„ãƒ¼ãƒ«ã¸ã®é–‹ç™ºè€…ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ–¹æ³•
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–** - å—ã‘å…¥ã‚Œå¯èƒ½ãªå…·ä½“çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–
4. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹** - ãƒ„ãƒ¼ãƒ«çµ±åˆã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å½±éŸ¿è©•ä¾¡
5. **ä¾å­˜é–¢ä¿‚ç®¡ç†** - ãƒ„ãƒ¼ãƒ«ã®ä¾å­˜é–¢ä¿‚ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç«¶åˆã®å‡¦ç†
6. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹/çŠ¶æ…‹ç§»è¡Œ** - çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹ãƒ„ãƒ¼ãƒ«ã®å¯¾å¿œ
7. **çµ±åˆãƒ†ã‚¹ãƒˆæˆ¦ç•¥** - å˜ä½“ãƒ†ã‚¹ãƒˆã‚’è¶…ãˆãŸçµ±åˆãƒ†ã‚¹ãƒˆ
8. **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ** - ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ã®äº‹å‰æ¤œè¨¼

#### å…·ä½“çš„ãªæ”¹å–„ææ¡ˆ

1. **ãƒ„ãƒ¼ãƒ«è¤‡é›‘åº¦ã‚«ãƒ†ã‚´ãƒªã®ä½œæˆ**
   - ç°¡å˜ï¼ˆ1-2é€±é–“ã®é«˜é€Ÿãƒˆãƒ©ãƒƒã‚¯ï¼‰
   - ä¸­ç¨‹åº¦ï¼ˆ3-4é€±é–“ã®æ¨™æº–ãƒˆãƒ©ãƒƒã‚¯ï¼‰
   - è¤‡é›‘ï¼ˆ6-8é€±é–“ã®åŒ…æ‹¬çš„ãƒˆãƒ©ãƒƒã‚¯ï¼‰

2. **çµ±åˆå‰è©•ä¾¡ã®å®Ÿè£…**
   ```javascript
   class IntegrationComplexityAssessor {
     assess(tool) {
       const factors = {
         codeLines: this.countLines(tool),
         dependencies: this.analyzeDependencies(tool),
         statefulness: this.hasState(tool),
         criticalPath: this.isInCriticalPath(tool),
         userCount: this.estimateUsers(tool)
       };
       return this.calculateComplexity(factors);
     }
   }
   ```

3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å›å¸°ãƒ†ã‚¹ãƒˆã®è¿½åŠ **
   ```javascript
   class PerformanceValidator {
     validatePerformance(baseline, current, threshold = 0.1) {
       const regression = (current - baseline) / baseline;
       return {
         passed: regression <= threshold,
         regression: regression * 100,
         details: this.generatePerformanceReport(baseline, current)
       };
     }
   }
   ```

#### ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æœ€çµ‚è©•ä¾¡

ã“ã®æ–¹é‡æ›¸ã¯ã€å®‰å…¨ãªãƒ„ãƒ¼ãƒ«çµ±åˆã®ãŸã‚ã®å„ªã‚ŒãŸåŸºç›¤ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚ææ¡ˆã•ã‚ŒãŸæ”¹å–„ã‚’åŠ ãˆã‚‹ã“ã¨ã§ã€è¤‡é›‘ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢çµ±åˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚´ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã«ã€å®Ÿè£…å¯èƒ½ãªã‚³ãƒ¼ãƒ‰ä¾‹ã¨è©³ç´°ãªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã¯ã€å³åº§ã«å®Ÿè·µã«ç§»ã›ã‚‹ä¾¡å€¤ãŒã‚ã‚Šã¾ã™ã€‚

ãŸã ã—ã€å®Ÿéš›ã®é‹ç”¨ã«ãŠã„ã¦ã¯ã€å„çµ„ç¹”ã®æ–‡è„ˆã«å¿œã˜ã¦ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã¨ãƒ—ãƒ­ã‚»ã‚¹ã®èª¿æ•´ãŒå¿…è¦ã§ã—ã‚‡ã†ã€‚

---

## ğŸ“‹ é–¢é€£æ–‡æ›¸

### è©³ç´°èª¿æŸ»è¨ˆç”»
æ„è¦‹å·®ç•°ã«åŸºã¥ãå„ªå…ˆåº¦ä»˜ãèª¿æŸ»é …ç›®ã«ã¤ã„ã¦ã¯ã€ä»¥ä¸‹ã®æ–‡æ›¸ã‚’å‚ç…§ï¼š
- **[ãƒ„ãƒ¼ãƒ«çµ±åˆè©³ç´°èª¿æŸ»è¨ˆç”»æ›¸](./TOOL_INTEGRATION_DETAILED_INVESTIGATION_20250120.md)** - AI Assistantã¨ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ„è¦‹å·®ç•°åˆ†æã¨å„ªå…ˆèª¿æŸ»é …ç›®

### èª­è§£ã‚¬ã‚¤ãƒ‰
åˆã‚ã¦ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«å‚åŠ ã•ã‚Œã‚‹æ–¹ã¯ã€ä»¥ä¸‹ã®ã‚¬ã‚¤ãƒ‰ã‹ã‚‰é–‹å§‹ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ï¼š
- **[ãƒ„ãƒ¼ãƒ«çµ±åˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­è§£ã‚¬ã‚¤ãƒ‰](./TOOL_INTEGRATION_READING_GUIDE_20250120.md)** - èƒŒæ™¯ã‹ã‚‰å®Ÿæ–½è¨ˆç”»ã¾ã§åŠ¹ç‡çš„ã«ç†è§£ã™ã‚‹ãŸã‚ã®èª­ã¿é †ã‚¬ã‚¤ãƒ‰